◆ React の基本ルール（総まとめ）
====================================
------------------------
◆ 1. UI は「状態 (State) の関数」
------------------------

React の根本原理：

UI = f(state)


コンポーネントは UI を返す関数

State・Props・Context が変われば、関数が再実行され UI が再計算される

DOM を直接いじらず、「状態が UI を決める」

------------------------
◆ 2. 再レンダリングは “UI を再計算しているだけ”
------------------------

React のレンダリングは軽い：

State 更新 → 関数を再実行して UI を再計算

最後に差分だけ DOM 更新（Fiber が担当）

DOM は全部書き換えない。
React が「差分更新」してくれる。

------------------------
◆ 3. Props は読み取り専用（子は書き換え不可）
------------------------

Props は “親から子への入力”

子が Props を変更するのは不可能（React の一方向データフロー）

変更したい場合は：

親が setState を渡す（onClick などのイベント）
子はそれを呼ぶ

------------------------
◆ 4. State はコンポーネント内部の「記憶領域」
------------------------

useState の本質：

コンポーネントが “覚えておきたい値”

setState が呼ばれると再レンダリング

State は直接書き換えてはいけない（immutability）

------------------------
◆ 5. Hooks は「コンポーネントに機能をフックする仕組み」
------------------------

代表的 Hooks：

useState：状態管理

useEffect：副作用（API, イベント登録など）

useMemo：値のメモ化

useCallback：関数のメモ化

useContext：Context 値を取り出す

Hooks の超重要ルール

コンポーネントのトップレベルでしか呼べない

条件分岐の中で呼んではいけない

“use” から始まる関数だけが Hook として認識される

------------------------
◆ 6. Context は「限定的なグローバル」
------------------------

Props を深く渡す問題（Prop Drilling）を解決

ただし Provider の value が変わると配下が全再レンダリング

小規模グローバルなら最適、大規模は不向き

------------------------
◆ 7. コンポーネントは “1つの責務” に限定する
------------------------

良い設計の基本：

Container（ロジック）

Presenter（UI）
に分離する。

悪い例：
1つのコンポーネントに
API取得・状態管理・UI・バリデーション・計算
全部詰め込む → 破綻する。

------------------------
◆ 8. Boolean フラグは乱用しない
------------------------

悪い例：

<Button primary disabled shadow large />


→ 組み合わせ爆発で管理不能。

良い例：

<Button variant="primary" size="large" disabled />


Props を「意味の軸」で整理する。

------------------------
◆ 9. Controlled と Uncontrolled の違い
------------------------
項目	Controlled	Uncontrolled
値の管理者	React	DOM
再レンダリング	毎回起きる	起きない
バリデーション	しやすい	送信時中心
用途	通常のフォーム	大規模・高速フォーム

React Hook Form は Uncontrolled ベース だから速い。

------------------------
◆ 10. パフォーマンス最適化の基本
------------------------
再レンダリングを減らしたいとき：

コンポーネントを分割する

React.memo

useCallback（関数のメモ化）

useMemo（重い計算のメモ化）

Context の乱用を避ける

最適化の本質は “不要な再レンダリング境界を作る” こと。

------------------------
◆ 11. 状態管理の選択（Context の限界と代替）
------------------------

Redux Toolkit：大規模向け（最強の予測可能性）

Zustand：軽量・シンプル（多くのアプリに最適）

Jotai：細粒度の atom ベース管理（React 的で読みやすい）

Context はあくまで「小規模グローバル」。